{"version":3,"sources":["webpack:///./src/blocks/modules/animation-pattern-lines/animation-pattern-lines.js"],"names":["AnimationPatternLines","selector","el","root","document","querySelector","url","getAttribute","animations","init","request","Axios","method","then","res","template","data","innerHTML","animate","catch","error","console","log","svgs","querySelectorAll","svg","svgIndex","io","IntersectionObserver","entries","isIntersecting","classList","contains","groups","group","groupIndex","delay","Math","floor","random","length","animation","anime","targets","strokeDashoffset","setDashoffset","easing","duration","direction","opacity","endDelay","i","update","begin","push","finished","add","observe","observerContainer","entry","play","pause"],"mappings":"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","file":"animation-pattern-lines.9e30.js","sourcesContent":["import anime from 'animejs';\r\nimport Axios from 'axios'\r\n\r\nexport default class AnimationPatternLines {\r\n    constructor(selector, el) {\r\n        this.selector = selector\r\n        this.root = el || document.querySelector(`[${this.selector}]`)\r\n        this.url = this.root.getAttribute(this.selector)\r\n        if (!this.root || !this.url) return false\r\n\r\n        this.animations = [];\r\n        this.init()\r\n    }\r\n    init() {\r\n        this.request()\r\n    }\r\n    request() {\r\n        Axios({\r\n            method: 'GET',\r\n            url: this.url\r\n        }).then(res => {\r\n            let template = res.data.template || res.data;\r\n\r\n            this.root.innerHTML = template\r\n\r\n            this.animate()\r\n        }).catch(error => {\r\n            console.log(error)\r\n        })\r\n    }\r\n    animate() {\r\n        let svgs = this.root.querySelectorAll('[data-svg]');\r\n\r\n        svgs.forEach((svg, svgIndex) => {\r\n\r\n            const io = new IntersectionObserver(entries => {\r\n                if (entries[0].isIntersecting) {\r\n                    if (!svg.classList.contains('is-inited')) {\r\n                        let groups = svg.querySelectorAll('[data-animate-group]');\r\n\r\n                        setTimeout(() => {\r\n                            groups.forEach((group, groupIndex) => {\r\n                                let delay = !svgIndex ? 0 : Math.floor(Math.random() * svgs.length) * 3000,\r\n                                    animation = anime({\r\n                                        targets: group.querySelectorAll('[data-stroke] path'),\r\n                                        strokeDashoffset: [anime.setDashoffset, 0],\r\n                                        easing: 'easeInOutCubic',\r\n                                        duration: 500,\r\n                                        direction: 'normal',\r\n                                        // loop: true,\r\n                                        opacity: [0, 1],\r\n                                        endDelay: delay,\r\n                                        delay: function (el, i) {\r\n                                            return i * 500 + delay\r\n                                        },\r\n                                        update: () => {\r\n                                        },\r\n                                        begin: () => {\r\n\r\n                                        }\r\n                                    });\r\n\r\n                                this.animations.push({\r\n                                    finished: false,\r\n                                    anime: animation\r\n\r\n                                });\r\n\r\n                                animation.finished.then(() => {\r\n                                    this.animations[groupIndex].finished = true\r\n                                })\r\n\r\n\r\n                            })\r\n                        }, 500);\r\n\r\n                        svg.classList.add('is-inited');\r\n                    }\r\n                }\r\n            }, {});\r\n\r\n            io.observe(svg);\r\n\r\n        })\r\n\r\n        const observerContainer = new IntersectionObserver(entries => {\r\n            entries.forEach(entry => {\r\n                if (entry.isIntersecting) {\r\n                    this.animations.forEach(animation => {\r\n                        if (!animation.finished) {\r\n                            animation.anime.play();\r\n                        }\r\n                    });\r\n                } else {\r\n                    this.animations.forEach(animation => {\r\n                        if (!animation.finished) {\r\n                            animation.anime.pause();\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n        }, {});\r\n\r\n        observerContainer.observe(this.root);\r\n    }\r\n}\r\n"],"sourceRoot":""}